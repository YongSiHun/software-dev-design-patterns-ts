# 행동 패턴 (Behavial Pattern)

- 객체나 클래스 간의 상호작용 방식을 정의하고 책임을 분리하여 유연하고 유지보수가 쉬운 코드를 작성하는데 중점을 두는 디자인 패턴

# 행동 패턴의 종류

#### 책임 연쇄 (Chain of Responsibility)

- 문제

  - 요청을 처리할 여러 객체가 있을 때 누가 처리할지 정하지 못한 경우

- 해결책
  - 요청을 처리할 객체들을 체인으로 연결하고 각 객체가 요청을 처리하거나 다음 객체로 넘김

#### 명령 (Command)

- 문제

  - 실행될 작업을 메서드 호출이나 객체를 통해 캡슐화 해야할 때

- 해결책
  - 작업 요청(명령)을 객체로 만들어 작업의 호출자와 실행자를 분리

#### 인터프리터 (Interpreter)

- 문제

  - 간단한 언어나 문법을 해석할 필요가 있을 때

- 해결책
  - 언어의 문법을 클래스 구조로 표현하고 이를 평가할 인터프리터를 작성

#### 이터레이터 (Iterator)

- 문제

  - 집합체 (리스트, 배열 등)의 내부 구조를 노출하지 않고 순회해야 할 때

- 해결책

  - 반복자를 만들어 집합체의 요소를 하나씩 접근하도록 함

#### 중재자 (Mediator)

- 문제

  - 객체 간의 직접적인 통신으로 인해 복잡성이 증가할 때

- 해결책
  - 중재자를 통해 객체들이 간접적으로 통신하도록 함

#### 메멘토 (Memento)

- 문제

  - 객체의 상태를 저장하고 나중에 복원할 필요가 있을 때

- 해결책
  - 객체의 상태를 변도로 저장하는 메멘토 객체를 사용

#### 구독자 (Observer)

- 문제

  - 한 객체의 상태 변경이 다른 객체들에게 자동으로 알려져야 할 때

- 해결책
  - 주체(Subject)가 상태 변경 시 구독자(Observer)들에게 알림을 보냄

#### 상태 (State)

- 문제

  - 객체의 상태에 따라 동작이 달라져야 할 때

- 해결책
  - 상태를 객체로 캡슐화하고 객체의 동작을 해당 상태에 위임

#### 전략 (Strategy)

- 문제

  - 알고리즘을 동적으로 교체할 필요가 있을 때

- 해결책
  - 알고리즘을 개별 클래스(전략)로 캡슐화하고 필요에 따라 교체

#### 템플릿 메서드 (Template Method)

- 문제

  - 알고리즘의 골격을 정의하고 세부 구현을 하위 클래스에 위임하고 싶을 때

- 해결책
  - 상위 클래스에서 알고리즘의 구조를 정의하고 하위 클래스에서 일부 단계를 구현

#### 방문자 (Visitor)

- 문제

  - 객체 구조의 각 요소에 대해 새로운 작업을 정의해야할 때

- 해결책
  - 방문자 객체를 만들어 작업을 캡슐화하고 구조의 요소들을 방문하면서 작업을 수행
